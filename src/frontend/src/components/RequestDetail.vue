<template>
  <div class="request-detail">
    <div v-if="!request" class="alert alert-secondary text-center">
      <i class="bi bi-arrow-left-circle"></i> 
      Select a request from the list to view details
    </div>
    
    <div v-else>
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h3>
          <span class="method-badge" :class="getMethodClass(request.method)">{{ request.method }}</span>
          Request Details
        </h3>
        <small class="text-muted">{{ formatDateTime(request.timestamp) }}</small>
      </div>
      
      <h5>URL</h5>
      <div class="url-container mb-3">
        {{ request.url }}
      </div>
      
      <ul class="nav nav-tabs mb-3" id="requestTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="headers-tab" data-bs-toggle="tab" data-bs-target="#headers" 
                  type="button" role="tab" aria-controls="headers" aria-selected="true">
            Headers
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="body-tab" data-bs-toggle="tab" data-bs-target="#body" 
                  type="button" role="tab" aria-controls="body" aria-selected="false">
            Request Body
          </button>
        </li>
        <li class="nav-item" role="presentation" v-if="responses && responses.length">
          <button class="nav-link" id="response-tab" data-bs-toggle="tab" data-bs-target="#response" 
                  type="button" role="tab" aria-controls="response" aria-selected="false">
            Response
          </button>
        </li>
      </ul>
      
      <div class="tab-content" id="requestTabsContent">
        <!-- Headers Tab -->
        <div class="tab-pane fade show active" id="headers" role="tabpanel" aria-labelledby="headers-tab">
          <div v-if="parsedHeaders" class="table-responsive">
            <table class="table table-striped table-sm">
              <thead>
                <tr>
                  <th scope="col">Header</th>
                  <th scope="col">Value</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(value, key) in parsedHeaders" :key="key">
                  <td>{{ key }}</td>
                  <td>{{ value }}</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div v-else class="alert alert-light">No headers found</div>
        </div>
        
        <!-- Body Tab -->
        <div class="tab-pane fade" id="body" role="tabpanel" aria-labelledby="body-tab">
          <div v-if="request.body" class="code-container">
            <pre><code>{{ formatBody(request.body) }}</code></pre>
          </div>
          <div v-else class="alert alert-light">No request body</div>
        </div>
        
        <!-- Response Tab -->
        <div class="tab-pane fade" id="response" role="tabpanel" aria-labelledby="response-tab">
          <div v-if="responses && responses.length">
            <div v-for="(response, index) in responses" :key="index" class="response-item mb-3">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <span class="status-badge" :class="getStatusClass(response.statusCode)">
                  Status: {{ response.statusCode }}
                </span>
                <small class="text-muted">{{ formatDateTime(response.timestamp) }}</small>
              </div>
              
              <div v-if="response.isFromRule" class="alert alert-warning mb-2">
                <i class="bi bi-exclamation-triangle"></i> This response was generated by a rule
              </div>
              
              <h6>Response Headers</h6>
              <div v-if="parseResponseHeaders(response)" class="table-responsive mb-3">
                <table class="table table-striped table-sm">
                  <thead>
                    <tr>
                      <th scope="col">Header</th>
                      <th scope="col">Value</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(value, key) in parseResponseHeaders(response)" :key="key">
                      <td>{{ key }}</td>
                      <td>{{ value }}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div v-else class="alert alert-light mb-3">No response headers</div>
              
              <h6>Response Body</h6>
              <div v-if="response.body" class="code-container">
                <pre><code>{{ formatBody(response.body) }}</code></pre>
              </div>
              <div v-else class="alert alert-light">No response body</div>
            </div>
          </div>
          <div v-else class="alert alert-light">No response recorded</div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'RequestDetail',
  
  props: {
    request: {
      type: Object,
      required: false,
      default: null
    }
  },
  
  computed: {
    parsedHeaders() {
      if (!this.request || !this.request.headers) return null;
      try {
        return JSON.parse(this.request.headers);
      } catch (e) {
        console.error('Error parsing headers:', e);
        return { error: 'Failed to parse headers' };
      }
    },
    
    responses() {
      if (!this.request || !this.request.responses) return [];
      return this.request.responses;
    }
  },
  
  methods: {
    parseResponseHeaders(response) {
      if (!response || !response.headers) return null;
      try {
        return JSON.parse(response.headers);
      } catch (e) {
        console.error('Error parsing response headers:', e);
        return { error: 'Failed to parse headers' };
      }
    },
    
    formatBody(body) {
      if (!body) return '';
      
      try {
        // Try to parse as JSON and pretty-print
        const parsedJson = JSON.parse(body);
        return JSON.stringify(parsedJson, null, 2);
      } catch (e) {
        // If not valid JSON, return as is
        return body;
      }
    },
    
    getMethodClass(method) {
      switch (method.toUpperCase()) {
        case 'GET':
          return 'method-get';
        case 'POST':
          return 'method-post';
        case 'PUT':
          return 'method-put';
        case 'DELETE':
          return 'method-delete';
        case 'PATCH':
          return 'method-patch';
        default:
          return 'method-other';
      }
    },
    
    getStatusClass(status) {
      if (status >= 200 && status < 300) {
        return 'status-success';
      } else if (status >= 300 && status < 400) {
        return 'status-redirect';
      } else if (status >= 400 && status < 500) {
        return 'status-client-error';
      } else if (status >= 500) {
        return 'status-server-error';
      } else {
        return 'status-other';
      }
    },
    
    formatDateTime(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleString();
    }
  }
};
</script>

<style scoped>
.request-detail {
  height: 100%;
  overflow-y: auto;
}

.url-container {
  background-color: #f8f9fa;
  padding: 10px;
  border-radius: 4px;
  font-family: monospace;
  word-break: break-all;
}

.code-container {
  background-color: #f8f9fa;
  padding: 10px;
  border-radius: 4px;
  overflow-x: auto;
}

pre {
  margin-bottom: 0;
}

code {
  color: #333;
  font-family: 'Courier New', Courier, monospace;
  white-space: pre-wrap;
}

.method-badge {
  padding: 3px 6px;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
  margin-right: 8px;
  width: 60px;
  display: inline-block;
  text-align: center;
}

.method-get {
  background-color: #61affe;
  color: white;
}

.method-post {
  background-color: #49cc90;
  color: white;
}

.method-put {
  background-color: #fca130;
  color: white;
}

.method-delete {
  background-color: #f93e3e;
  color: white;
}

.method-patch {
  background-color: #50e3c2;
  color: white;
}

.method-other {
  background-color: #747474;
  color: white;
}

.status-badge {
  padding: 3px 6px;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
}

.status-success {
  background-color: #49cc90;
  color: white;
}

.status-redirect {
  background-color: #fca130;
  color: white;
}

.status-client-error {
  background-color: #f93e3e;
  color: white;
}

.status-server-error {
  background-color: #9012fe;
  color: white;
}

.status-other {
  background-color: #747474;
  color: white;
}

.response-item {
  padding: 15px;
  border: 1px solid #dee2e6;
  border-radius: 4px;
}
</style>
